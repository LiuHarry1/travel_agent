# 工具检测（Tool Detection）详解

## 什么是工具检测？

**工具检测**是指在执行工具之前，先调用 LLM（大语言模型）来判断用户的问题是否需要使用工具，以及需要使用哪个工具。

## 工作流程

```
用户问题
    ↓
工具检测（调用 LLM）
    ↓
LLM 分析问题
    ↓
决定是否需要工具？
    ├─ 是 → 返回工具名称和参数 → 执行工具
    └─ 否 → 直接生成回答
```

## 具体例子

### 例子 1：需要工具的情况

**用户问题**: "如何申请日本旅游签证？"

**工具检测过程**:
1. 系统调用 LLM，提供：
   - 用户问题："如何申请日本旅游签证？"
   - 可用工具列表：`faq`, `retriever`, `tavily-search` 等
2. LLM 分析后返回：
   ```json
   {
     "function_call": {
       "name": "faq",
       "arguments": {"query": "如何申请日本旅游签证"}
     }
   }
   ```
3. 系统执行 `faq` 工具
4. 如果 FAQ 没找到答案，工具结果建议使用 `retriever`
5. **再次进行工具检测**（这就是第二次工具检测）
6. LLM 分析后返回：
   ```json
   {
     "function_call": {
       "name": "retriever",
       "arguments": {"query": "如何申请日本旅游签证"}
     }
   }
   ```
7. 系统执行 `retriever` 工具
8. 最后生成最终回答

### 例子 2：不需要工具的情况

**用户问题**: "你好"

**工具检测过程**:
1. 系统调用 LLM
2. LLM 分析后返回：
   ```json
   {
     "content": "你好！我是您的旅行助手..."
   }
   ```
3. 没有 `function_call`，说明不需要工具
4. 直接返回 LLM 生成的内容

## 为什么需要工具检测？

1. **智能决策**: LLM 可以根据问题的复杂程度和类型，决定是否需要调用工具
2. **选择合适的工具**: 如果有多个工具可用，LLM 可以选择最合适的工具
3. **生成工具参数**: LLM 可以根据问题生成正确的工具调用参数

## 性能问题

### 当前实现的问题

从日志可以看到：
- **Iteration 1**: 工具检测耗时 1.127s
- **Iteration 2**: 工具检测耗时 1.402s
- **总计**: 2.529s（占总时间的 37.7%）

### 为什么这么慢？

1. **每次都要调用 LLM**: 工具检测需要调用 LLM API，网络请求 + LLM 推理需要时间
2. **串行执行**: 工具检测 → 工具执行 → 工具检测 → 工具执行，无法并行
3. **重复检测**: 如果工具结果明确建议使用另一个工具，仍然需要再次检测

## 优化方案

### 方案 1：智能工具链（跳过不必要的检测）

**当前流程**:
```
工具结果（建议使用 retriever）
    ↓
工具检测（调用 LLM，耗时 1.4s）← 这一步可以跳过
    ↓
执行 retriever 工具
```

**优化后流程**:
```
工具结果（建议使用 retriever）
    ↓
直接执行 retriever 工具（节省 1.4s）
```

**实现方式**:
- 如果工具结果包含 `_suggests_more_tools=True` 和明确的工具名称
- 直接构造工具调用，跳过 LLM 检测

### 方案 2：减少 max_tokens

**当前**: `max_tokens = 500`
**优化**: `max_tokens = 200-300`

**原因**: 工具检测只需要返回工具名称和参数，不需要生成长文本，减少 tokens 可以：
- 减少 LLM 推理时间
- 减少网络传输时间
- 节省成本

**预期效果**: 节省 ~0.3-0.5s

### 方案 3：并行工具检测和执行（如果多个工具）

如果检测到需要调用多个工具，可以并行执行，而不是串行。

## 代码位置

工具检测的实现在：
- `backend/app/service/chat.py` 的 `_detect_tool_calls()` 方法
- 调用 LLM API，传入工具定义列表
- LLM 返回是否需要调用工具，以及调用哪个工具

## 总结

工具检测是必要的，因为它让系统能够智能地决定何时使用工具。但可以通过以下方式优化：

1. ✅ **智能工具链**: 如果工具结果明确建议，直接调用，跳过检测
2. ✅ **减少 max_tokens**: 工具检测不需要太多 tokens
3. 💡 **并行执行**: 如果多个工具，可以并行执行

这些优化可以节省约 1.7-1.9 秒（从 2.5s 降到 ~0.6-0.8s），提升约 68-76% 的性能。

